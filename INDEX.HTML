<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Teacher Platform - Full Flow with Simulated Avatar</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        .container {
            max-width: 90%; /* Fluid width for responsiveness */
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: #ffffff;
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .pdf-viewer {
            width: 100%;
            height: 70vh; /* Responsive height */
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            margin-top: 1.5rem;
        }
        /* Message box for alerts */
        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none; /* Hidden by default */
            font-size: 0.9rem;
        }
        .hidden {
            display: none;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: none; /* Hidden by default */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="antialiased text-gray-800">
    <div id="message-box"></div>

    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-6 text-indigo-700">AI Teacher Platform</h1>
        <p class="text-center text-gray-600 mb-8">Upload a PDF to get started with your AI-powered lesson!</p>

        <!-- PDF Upload Section -->
        <div class="flex flex-col items-center mb-8">
            <label for="pdf-upload" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg cursor-pointer transition duration-300 ease-in-out shadow-md">
                Upload PDF(s) & DOC(s)
            </label>
            <input type="file" id="pdf-upload" accept=".pdf, .docx, application/vnd.openxmlformats-officedocument.wordprocessingml.document" multiple class="hidden" onchange="handlePdfUpload(event)">
            <span id="file-name" class="mt-4 text-gray-700 italic">No file chosen</span>
            <button id="extract-text-button" class="mt-6 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-5 rounded-lg transition duration-300 ease-in-out shadow-md hidden" onclick="extractText()">
                Extract Text
            </button>
            <div id="loading-spinner-extract" class="loader mt-4"></div>
        </div>

        <!-- PDF Viewer Section -->
        <div id="pdf-viewer-container" class="pdf-viewer mb-8">
            <p class="text-center text-gray-500 mt-4">Your uploaded PDFs will appear here (first file shown).</p>
            <iframe id="pdf-iframe" class="hidden pdf-viewer" frameborder="0"></iframe>
        </div>

        <!-- Extracted Text Section -->
        <div class="bg-gray-50 p-6 rounded-lg shadow-inner mb-8">
            <h2 class="text-2xl font-bold text-indigo-700 mb-4">Extracted Text</h2>
            <div id="extracted-text-output" class="min-h-[150px] bg-white p-4 rounded-md border border-gray-200 overflow-y-auto text-gray-700 text-sm leading-relaxed">
                <p class="text-gray-500 italic">Extracted text will appear here.</p>
            </div>
            <div class="flex flex-wrap justify-center gap-4 mt-6">
                <button id="generate-summary-button" class="bg-yellow-600 hover:bg-yellow-700 text-white font-semibold py-2 px-5 rounded-lg transition duration-300 ease-in-out shadow-md hidden" onclick="generateSummary()">
                    Summarize All Files
                </button>
                <button id="generate-audio-button" class="bg-orange-600 hover:bg-orange-700 text-white font-semibold py-2 px-5 rounded-lg transition duration-300 ease-in-out shadow-md hidden" onclick="generateAndPlayAudio()">
                    Generate and Play Audio (from Extracted Text)
                </button>
                <button id="generate-script-button" class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-5 rounded-lg transition duration-300 ease-in-out shadow-md hidden" onclick="generateTeachingScript()">
                    Generate Teaching Script
                </button>
            </div>
            <div id="loading-spinner-script" class="loader mt-4"></div>
            <div id="loading-spinner-audio" class="loader mt-4"></div>
            <div id="loading-spinner-summary" class="loader mt-4"></div>
        </div>

        <!-- AI-Generated Summarized Text Section -->
        <div class="bg-yellow-50 p-6 rounded-lg shadow-inner mb-8">
            <h2 class="text-2xl font-bold text-indigo-700 mb-4">AI-Generated Summary</h2>
            <div id="summarized-text-output" class="min-h-[150px] bg-white p-4 rounded-md border border-gray-200 overflow-y-auto text-gray-700 text-sm leading-relaxed whitespace-pre-wrap">
                <p class="text-gray-500 italic">The AI-generated summary will appear here.</p>
            </div>
        </div>

        <!-- AI-Generated Teaching Script Section -->
        <div class="bg-blue-50 p-6 rounded-lg shadow-inner mb-8">
            <h2 class="text-2xl font-bold text-indigo-700 mb-4">AI-Generated Teaching Script</h2>
            <div id="generated-script-output" class="min-h-[200px] bg-white p-4 rounded-md border border-gray-200 overflow-y-auto text-gray-700 text-base leading-relaxed whitespace-pre-wrap">
                <p class="text-gray-500 italic">The AI-generated teaching script will appear here.</p>
            </div>
            <div class="flex flex-wrap justify-center gap-4 mt-6">
                <button id="generate-audio-from-script-button" class="bg-orange-600 hover:bg-orange-700 text-white font-semibold py-2 px-5 rounded-lg transition duration-300 ease-in-out shadow-md hidden" onclick="generateAndPlayAudio(true)">
                    Generate and Play Audio (from Script)
                </button>
                <button id="generate-avatar-video-button" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-5 rounded-lg transition duration-300 ease-in-out shadow-md hidden" onclick="generateAvatarVideo()">
                    Generate Avatar Video
                </button>
            </div>
            <div id="loading-spinner-avatar" class="loader mt-4"></div>
        </div>

        <!-- Audio Player Section -->
        <div class="bg-teal-50 p-6 rounded-lg shadow-inner mb-8">
            <h2 class="text-2xl font-bold text-indigo-700 mb-4">Listen to the Lecture</h2>
            <div id="audio-player-container" class="min-h-[80px] flex items-center justify-center bg-white p-4 rounded-md border border-gray-200">
                <p class="text-gray-500 italic">Audio will be generated and appear here.</p>
                <audio id="lecture-audio" controls class="w-full max-w-lg hidden"></audio>
            </div>
        </div>

        <!-- Avatar Video Player Section -->
        <div class="bg-yellow-50 p-6 rounded-lg shadow-inner">
            <h2 class="text-2xl font-bold text-indigo-700 mb-4">AI Teacher Video</h2>
            <div id="avatar-video-container" class="min-h-[300px] flex items-center justify-center bg-white p-4 rounded-md border border-gray-200">
                <p class="text-gray-500 italic">The AI avatar video will appear here.</p>
                <video id="avatar-video" controls class="w-full max-w-2xl rounded-md shadow-lg hidden" poster="https://placehold.co/640x360/e0e7ff/4338ca?text=AI+Avatar+Placeholder"></video>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script>
        // Set up the worker source for pdf.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';

        let uploadedPdfFiles = []; 
        let lastExtractedText = ''; 
        let lastGeneratedScript = ''; 
        const BACKEND_BASE = (window.BACKEND_BASE || 'http://localhost:8000').replace(/\/$/, '');

        // Function to show custom message box
        function showMessage(message, duration = 3000) {
            const messageBox = document.getElementById('message-box');
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, duration);
        }

        /**
         * Shows or hides a specific loading spinner.
         * @param {string} spinnerId - The ID of the spinner element.
         * @param {boolean} show - True to show, false to hide.
         */
        function showLoadingSpinner(spinnerId, show) {
            const spinner = document.getElementById(spinnerId);
            if (show) {
                spinner.style.display = 'block';
            } else {
                spinner.style.display = 'none';
            }
        }

        async function checkBackendHealth() {
            try {
                const resp = await fetch(`${BACKEND_BASE}/health`);
                if (!resp.ok) throw new Error(`status ${resp.status}`);
                const data = await resp.json();
                if (data?.status === 'ok') {
                    showMessage('Connected to backend.');
                } else {
                    showMessage('Backend health check returned unexpected response.', 5000);
                }
            } catch (e) {
                showMessage('Cannot reach backend. Please start the server on port 8000.', 7000);
                console.error('Health check failed:', e);
            }
        }

        /**
         * Base64 to ArrayBuffer conversion for audio data.
         * @param {string} base64 - Base64 encoded string.
         * @returns {ArrayBuffer}
         */
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /**
         * Converts PCM audio data to WAV format.
         * @param {Int16Array} pcm16 - PCM audio data (16-bit signed).
         * @param {number} sampleRate - Sample rate of the audio.
         * @returns {Blob} WAV audio blob.
         */
        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2; // 16-bit PCM

            const buffer = new ArrayBuffer(44 + pcm16.length * bytesPerSample);
            const view = new DataView(buffer);

            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcm16.length * bytesPerSample, true);
            writeString(view, 8, 'WAVE');

            // FMT sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // Sub-chunk size
            view.setUint16(20, 1, true); // Audio format (1 = PCM)
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * bytesPerSample, true); // Byte rate
            view.setUint16(32, numChannels * bytesPerSample, true); // Block align
            view.setUint16(34, 16, true); // Bits per sample

            // DATA sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, pcm16.length * bytesPerSample, true);

            // Write PCM data
            let offset = 44;
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += bytesPerSample;
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }

        /**
         * Helper function to write a string to a DataView.
         * @param {DataView} view
         * @param {number} offset
         * @param {string} string
         */
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        /**
         * Resets UI elements related to script, audio, and avatar video generation.
         */
        function resetGenerationUIs() {
            const generateSummaryButton = document.getElementById('generate-summary-button');
            const generateScriptButton = document.getElementById('generate-script-button');
            const generateAudioButton = document.getElementById('generate-audio-button');
            const generateAudioFromScriptButton = document.getElementById('generate-audio-from-script-button');
            const generateAvatarVideoButton = document.getElementById('generate-avatar-video-button');
            const extractedTextOutput = document.getElementById('extracted-text-output');
            const summarizedTextOutput = document.getElementById('summarized-text-output');
            const generatedScriptOutput = document.getElementById('generated-script-output');
            const audioPlayerContainer = document.getElementById('audio-player-container');
            const lectureAudio = document.getElementById('lecture-audio');
            const avatarVideoContainer = document.getElementById('avatar-video-container');
            const avatarVideo = document.getElementById('avatar-video');

            generateSummaryButton?.classList.add('hidden');
            generateScriptButton?.classList.add('hidden');
            generateAudioButton?.classList.add('hidden');
            generateAudioFromScriptButton?.classList.add('hidden');
            generateAvatarVideoButton?.classList.add('hidden');
            
            extractedTextOutput.innerHTML = '<p class="text-gray-500 italic">Extracted text will appear here.</p>';
            summarizedTextOutput.innerHTML = '<p class="text-gray-500 italic">The AI-generated summary will appear here.</p>';
            generatedScriptOutput.innerHTML = '<p class="text-gray-500 italic">The AI-generated teaching script will appear here.</p>';
            audioPlayerContainer.innerHTML = '<p class="text-gray-500 italic">Audio will be generated and appear here.</p>';
            lectureAudio?.classList.add('hidden');
            if (lectureAudio) lectureAudio.src = ''; 

            avatarVideoContainer.innerHTML = '<p class="text-gray-500 italic">The AI avatar video will appear here.</p>';
            avatarVideo?.classList.add('hidden');
            if (avatarVideo) avatarVideo.src = ''; 

            lastExtractedText = '';
            lastGeneratedScript = '';
        }

        /**
         * Handles the file upload event.
         * @param {Event} event - The file input change event.
         */
        function handlePdfUpload(event) {
            const files = event.target.files;
            const fileNameSpan = document.getElementById('file-name');
            const pdfIframe = document.getElementById('pdf-iframe');
            const placeholderText = document.querySelector('#pdf-viewer-container p');
            const extractButton = document.getElementById('extract-text-button');
            
            if (files.length > 0) {
                uploadedPdfFiles = Array.from(files); // Store files as an array
                const fileNames = uploadedPdfFiles.map(f => f.name).join(', ');
                fileNameSpan.textContent = fileNames;
                
                const firstFile = uploadedPdfFiles[0];
                if (firstFile.type === 'application/pdf') {
                    // Only show the first PDF in the viewer
                    const fileURL = URL.createObjectURL(firstFile);
                    pdfIframe.src = fileURL;
                    pdfIframe.classList.remove('hidden');
                    placeholderText?.classList.add('hidden');
                } else {
                    pdfIframe.src = '';
                    pdfIframe.classList.add('hidden');
                    placeholderText?.classList.remove('hidden');
                }
                
                extractButton.classList.remove('hidden'); 
                
                resetGenerationUIs(); // Reset all generated content UIs
                showMessage('File(s) uploaded successfully!');
            } else {
                uploadedPdfFiles = [];
                fileNameSpan.textContent = 'No file chosen';
                pdfIframe.src = '';
                pdfIframe.classList.add('hidden');
                placeholderText?.classList.remove('hidden');
                extractButton.classList.add('hidden'); 
                
                resetGenerationUIs(); // Reset all generated content UIs
                showMessage('Please upload a valid file.', 5000);
                event.target.value = ''; // Clear the input
            }
        }

        /**
         * Extracts text from the uploaded PDF/DOCX files.
         */
        async function extractText() {
            if (uploadedPdfFiles.length === 0) {
                showMessage('Please upload file(s) first.', 3000);
                return;
            }

            showLoadingSpinner('loading-spinner-extract', true);
            const extractButton = document.getElementById('extract-text-button');
            const generateSummaryButton = document.getElementById('generate-summary-button');
            const generateScriptButton = document.getElementById('generate-script-button');
            const generateAudioButton = document.getElementById('generate-audio-button');
            const generateAudioFromScriptButton = document.getElementById('generate-audio-from-script-button');
            const generateAvatarVideoButton = document.getElementById('generate-avatar-video-button');

            extractButton.disabled = true; 
            extractButton.classList.add('opacity-50', 'cursor-not-allowed');
            
            generateSummaryButton?.classList.add('hidden');
            generateScriptButton?.classList.add('hidden');
            generateAudioButton?.classList.add('hidden');
            generateAudioFromScriptButton?.classList.add('hidden');
            generateAvatarVideoButton?.classList.add('hidden');

            const extractedTextOutput = document.getElementById('extracted-text-output');
            extractedTextOutput.innerHTML = '<p class="text-gray-600 italic">Extracting text...</p>';
            let fullText = '';
            let isDocx = false;

            try {
                for (const file of uploadedPdfFiles) {
                    if (file.type === 'application/pdf') {
                        const reader = new FileReader();
                        const typedarray = await new Promise((resolve, reject) => {
                            reader.onload = () => resolve(new Uint8Array(reader.result));
                            reader.onerror = reject;
                            reader.readAsArrayBuffer(file);
                        });
                        
                        const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            const pageText = textContent.items.map(item => item.str).join(' ');
                            fullText += pageText + '\n\n'; 
                        }
                    } else if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                        isDocx = true;
                        // For a real application, you'd send this to a backend API.
                        // We will simulate text extraction here for the demonstration.
                        fullText += '(Simulated text from DOCX: The document covers topics on machine learning models, neural networks, and supervised vs. unsupervised learning. It also includes sections on data preprocessing and model evaluation metrics.)\n\n';
                    } else {
                        // Skip other file types
                    }
                }
                
                if (isDocx) {
                    showMessage('DOCX files require a server-side parser. Using simulated text for demo.', 7000);
                }

                if (fullText.trim() === '') {
                    extractedTextOutput.innerHTML = '<p class="text-red-600">No text could be extracted from these files.</p>';
                    showMessage('No text found in the files.', 5000);
                    lastExtractedText = ''; 
                } else {
                    lastExtractedText = fullText.trim(); 
                    extractedTextOutput.textContent = lastExtractedText;
                    
                    // Show relevant buttons after text extraction
                    generateSummaryButton?.classList.remove('hidden');
                    generateAudioButton?.classList.remove('hidden'); 
                    generateScriptButton?.classList.remove('hidden'); 
                    showMessage('Text extracted successfully! Ready for audio, script or summary generation.');
                }

            } catch (error) {
                console.error('Error extracting text:', error);
                extractedTextOutput.innerHTML = `<p class="text-red-600">Error extracting text: ${error.message}</p>`;
                showMessage('Failed to extract text from file(s).', 5000);
                lastExtractedText = ''; 
            } finally {
                showLoadingSpinner('loading-spinner-extract', false);
                extractButton.disabled = false; 
                extractButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        /**
         * Generates a teaching script using the Gemini API based on the extracted text.
         */
        async function generateTeachingScript() {
            if (!lastExtractedText) {
                showMessage('Please extract text from a PDF first.', 3000);
                return;
            }

            showLoadingSpinner('loading-spinner-script', true);
            const generateSummaryButton = document.getElementById('generate-summary-button');
            const generateScriptButton = document.getElementById('generate-script-button');
            const generateAudioButton = document.getElementById('generate-audio-button'); 
            const generateAudioFromScriptButton = document.getElementById('generate-audio-from-script-button'); 
            const generateAvatarVideoButton = document.getElementById('generate-avatar-video-button');

            generateScriptButton.disabled = true;
            generateScriptButton.classList.add('opacity-50', 'cursor-not-allowed');
            
            // Hide relevant buttons during script generation
            generateSummaryButton?.classList.add('hidden');
            generateAudioButton?.classList.add('hidden'); 
            generateAudioFromScriptButton?.classList.add('hidden'); 
            generateAvatarVideoButton?.classList.add('hidden');

            const generatedScriptOutput = document.getElementById('generated-script-output');
            generatedScriptOutput.innerHTML = '<p class="text-gray-600 italic">Generating script with AI...</p>';
            
            const audioPlayerContainer = document.getElementById('audio-player-container');
            const lectureAudio = document.getElementById('lecture-audio');
            audioPlayerContainer.innerHTML = '<p class="text-gray-500 italic">Audio will be generated and appear here.</p>'; 
            lectureAudio?.classList.add('hidden');
            if (lectureAudio) lectureAudio.src = ''; 

            const avatarVideoContainer = document.getElementById('avatar-video-container');
            const avatarVideo = document.getElementById('avatar-video');
            avatarVideoContainer.innerHTML = '<p class="text-gray-500 italic">The AI avatar video will appear here.</p>';
            avatarVideo?.classList.add('hidden');
            if (avatarVideo) avatarVideo.src = ''; 

            lastGeneratedScript = ''; 

            const prompt = `Based on the following text from a PDF, please generate a structured and engaging teaching script. The script should be suitable for an AI avatar to present as a lecture. Include an introduction, clear explanations of key concepts, and a conclusion. Make it sound like a friendly and knowledgeable teacher.

Extracted Text:
${lastExtractedText}`;

            const apiUrl = `${BACKEND_BASE}/script`;
            const payload = { text: lastExtractedText };

            // Exponential backoff retry logic
            const maxRetries = 5;
            let retryCount = 0;
            let response;

            while (retryCount < maxRetries) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        let errorData;
                        try { errorData = await response.json(); } catch { errorData = { detail: 'Unknown error' }; }
                        console.error('API Error:', errorData);
                        if (response.status === 429 || (response.status >= 500 && response.status < 600)) {
                            const delay = Math.pow(2, retryCount) * 1000; 
                            console.warn(`Retrying in ${delay / 1000} seconds... (Attempt ${retryCount + 1})`);
                            await new Promise(res => setTimeout(res, delay));
                            retryCount++;
                            continue; 
                        } else {
                            throw new Error(`API returned status ${response.status}: ${JSON.stringify(errorData)}`);
                        }
                    }
                    // If successful, break the loop
                    break;

                } catch (error) {
                    console.error('Fetch error:', error);
                    generatedScriptOutput.innerHTML = `<p class="text-red-600">Error generating script: ${error.message}</p>`;
                    showMessage('Failed to generate script. Please try again.', 5000);
                    showLoadingSpinner('loading-spinner-script', false);
                    generateScriptButton.disabled = false;
                    generateScriptButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    return; 
                }
            }

            if (!response || !response.ok) {
                 generatedScriptOutput.innerHTML = '<p class="text-red-600">Max retries reached. Failed to generate script.</p>';
                 showMessage('Failed to generate script after multiple attempts.', 5000);
                 showLoadingSpinner('loading-spinner-script', false);
                 generateScriptButton.disabled = false;
                 generateScriptButton.classList.remove('opacity-50', 'cursor-not-allowed');
                 return;
            }


            try {
                const result = await response.json();
                const scriptText = result?.script;
                if (scriptText) {
                    lastGeneratedScript = scriptText; 
                    generatedScriptOutput.textContent = scriptText;
                    
                    generateAudioFromScriptButton?.classList.remove('hidden'); 
                    generateAvatarVideoButton?.classList.remove('hidden'); // Show avatar video button after script
                    showMessage('Teaching script generated successfully! Ready for audio or video generation.');
                } else {
                    generatedScriptOutput.innerHTML = '<p class="text-red-600">Could not generate a script. The AI response was empty or malformed.</p>';
                    showMessage('AI did not return a valid script.', 5000);
                    console.error('Malformed backend response:', result);
                    lastGeneratedScript = ''; 
                }
            } catch (error) {
                console.error('Error parsing AI response or accessing content:', error);
                generatedScriptOutput.innerHTML = `<p class="text-red-600">Error processing AI response: ${error.message}</p>`;
                showMessage('Error processing AI response.', 5000);
                lastGeneratedScript = ''; 
            } finally {
                showLoadingSpinner('loading-spinner-script', false);
                generateScriptButton.disabled = false;
                generateScriptButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        /**
         * Generates and plays audio using the Gemini TTS API.
         * @param {boolean} useScript - If true, uses lastGeneratedScript. Otherwise, uses lastExtractedText.
         */
        async function generateAndPlayAudio(useScript = false) {
            let textToSpeak = '';
            let sourceMessage = '';

            if (useScript) {
                if (!lastGeneratedScript) {
                    showMessage('Please generate a teaching script first.', 3000);
                    return;
                }
                textToSpeak = lastGeneratedScript;
                sourceMessage = 'from the generated script';
            } else {
                if (!lastExtractedText) {
                    showMessage('Please extract text from a PDF first.', 3000);
                    return;
                }
                textToSpeak = lastExtractedText;
                sourceMessage = 'from the extracted text';
            }

            showLoadingSpinner('loading-spinner-audio', true);
            const generateAudioButton = document.getElementById('generate-audio-button');
            const generateAudioFromScriptButton = document.getElementById('generate-audio-from-script-button');
            const generateSummaryButton = document.getElementById('generate-summary-button');
            const generateScriptButton = document.getElementById('generate-script-button');

            // Disable all relevant buttons during generation
            generateAudioButton?.setAttribute('disabled', 'true');
            generateAudioButton?.classList.add('opacity-50', 'cursor-not-allowed');
            generateAudioFromScriptButton?.setAttribute('disabled', 'true');
            generateAudioFromScriptButton?.classList.add('opacity-50', 'cursor-not-allowed');
            generateSummaryButton?.setAttribute('disabled', 'true');
            generateSummaryButton?.classList.add('opacity-50', 'cursor-not-allowed');
            generateScriptButton?.setAttribute('disabled', 'true');
            generateScriptButton?.classList.add('opacity-50', 'cursor-not-allowed');

            const audioPlayerContainer = document.getElementById('audio-player-container');
            const lectureAudio = document.getElementById('lecture-audio');
            audioPlayerContainer.innerHTML = `<p class="text-gray-600 italic">Generating audio ${sourceMessage}...</p>`;
            
            lectureAudio?.classList.add('hidden');
            if (lectureAudio) lectureAudio.src = ''; 

            const apiUrl = `${BACKEND_BASE}/tts`;
            const payload = { text: textToSpeak, voice_name: "Kore" };

            // Exponential backoff retry logic for TTS
            const maxRetries = 5;
            let retryCount = 0;
            let response;
            let rawResponseText = ''; 

            while (retryCount < maxRetries) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        let errorData = { message: "Unknown error or could not parse response." };
                        try { errorData = await response.json(); } catch {}
                        
                        console.error('TTS API Error:', errorData);

                        if (response.status === 429 || (response.status >= 500 && response.status < 600)) {
                            const delay = Math.pow(2, retryCount) * 1000;
                            console.warn(`TTS Retrying in ${delay / 1000} seconds... (Attempt ${retryCount + 1})`);
                            await new Promise(res => setTimeout(res, delay));
                            retryCount++;
                            continue;
                        } else {
                            throw new Error(`TTS API returned status ${response.status}: ${JSON.stringify(errorData)}`);
                        }
                    }
                    break;

                } catch (error) {
                    console.error('TTS Fetch error:', error);
                    audioPlayerContainer.innerHTML = `<p class="text-red-600">Error generating audio: ${error.message}</p>`;
                    showMessage('Failed to generate audio. Please try again.', 5000);
                    showLoadingSpinner('loading-spinner-audio', false);
                    
                    // Re-enable all relevant buttons on error
                    generateAudioButton?.removeAttribute('disabled');
                    generateAudioButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                    generateAudioFromScriptButton?.removeAttribute('disabled');
                    generateAudioFromScriptButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                    generateSummaryButton?.removeAttribute('disabled');
                    generateSummaryButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                    generateScriptButton?.removeAttribute('disabled');
                    generateScriptButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                    return;
                }
            }

            if (!response || !response.ok) {
                audioPlayerContainer.innerHTML = '<p class="text-red-600">Max retries reached. Failed to generate audio.</p>';
                showMessage('Failed to generate audio after multiple attempts.', 5000);
                showLoadingSpinner('loading-spinner-audio', false);
                
                // Re-enable all relevant buttons after max retries
                generateAudioButton?.removeAttribute('disabled');
                generateAudioButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                generateAudioFromScriptButton?.removeAttribute('disabled');
                generateAudioFromScriptButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                generateSummaryButton?.removeAttribute('disabled');
                generateSummaryButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                generateScriptButton?.removeAttribute('disabled');
                generateScriptButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                return;
            }

            try {
                const result = await response.json();
                const audioB64 = result?.data;
                const mimeType = result?.mimeType || 'audio/wav';
                if (audioB64) {
                    const byteCharacters = atob(audioB64);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    const wavBlob = new Blob([byteArray], { type: mimeType });
                    const audioUrl = URL.createObjectURL(wavBlob);

                    audioPlayerContainer.innerHTML = '';
                    if (lectureAudio) {
                        lectureAudio.src = audioUrl;
                        lectureAudio.classList.remove('hidden');
                        lectureAudio.play();
                    }
                    showMessage('Audio generated and playing!');
                } else {
                    audioPlayerContainer.innerHTML = '<p class="text-red-600">Could not generate audio. Backend returned no audio data.</p>';
                    showMessage('Backend did not return valid audio.', 5000);
                    console.error('Malformed backend audio response:', result);
                }
            } catch (error) {
                console.error('Error processing AI audio response:', error);
                audioPlayerContainer.innerHTML = `<p class="text-red-600">Error processing audio response: ${error.message}</p>`;
                showMessage('Error processing audio response. See console for details.', 5000);
            } finally {
                showLoadingSpinner('loading-spinner-audio', false);
                
                // Re-enable all relevant buttons on success or error
                generateAudioButton?.removeAttribute('disabled');
                generateAudioButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                generateAudioFromScriptButton?.removeAttribute('disabled');
                generateAudioFromScriptButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                generateSummaryButton?.removeAttribute('disabled');
                generateSummaryButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                generateScriptButton?.removeAttribute('disabled');
                generateScriptButton?.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        /**
         * Simulates generating an AI avatar video based on the generated script.
         * In a real application, this would call an external AI avatar video generation API.
         */
        async function generateAvatarVideo() {
            if (!lastGeneratedScript) {
                showMessage('Please generate a teaching script first to create an avatar video.', 3000);
                return;
            }

            showLoadingSpinner('loading-spinner-avatar', true);
            const generateSummaryButton = document.getElementById('generate-summary-button');
            const generateScriptButton = document.getElementById('generate-script-button');
            const generateAudioButton = document.getElementById('generate-audio-button');
            const generateAudioFromScriptButton = document.getElementById('generate-audio-from-script-button');
            const generateAvatarVideoButton = document.getElementById('generate-avatar-video-button');

            generateAvatarVideoButton?.setAttribute('disabled', 'true');
            generateAvatarVideoButton?.classList.add('opacity-50', 'cursor-not-allowed');
            generateAudioFromScriptButton?.setAttribute('disabled', 'true');
            generateAudioFromScriptButton?.classList.add('opacity-50', 'cursor-not-allowed');
            generateSummaryButton?.setAttribute('disabled', 'true');
            generateSummaryButton?.classList.add('opacity-50', 'cursor-not-allowed');
            generateScriptButton?.setAttribute('disabled', 'true');
            generateScriptButton?.classList.add('opacity-50', 'cursor-not-allowed');

            const avatarVideoContainer = document.getElementById('avatar-video-container');
            const avatarVideo = document.getElementById('avatar-video');
            avatarVideoContainer.innerHTML = '<p class="text-gray-600 italic">Generating AI avatar video...</p>';
            avatarVideo?.classList.add('hidden');
            if (avatarVideo) avatarVideo.src = ''; 

            // Simulate API call for avatar video generation
            // In a real scenario, you'd call an external service like Synthesia, D-ID, etc.
            // These services typically take the script (or audio) and return a video URL.
            const simulatedVideoUrl = 'https://www.w3schools.com/html/mov_bbb.mp4'; // Example video or placeholder

            // Simulate a delay for the "AI generation"
            await new Promise(resolve => setTimeout(resolve, 5000)); // 5-second delay

            try {
                // In a real API response, you would parse for the video URL.
                // For simulation, we directly use the simulatedVideoUrl.
                if (simulatedVideoUrl) {
                    avatarVideoContainer.innerHTML = ''; // Clear placeholder
                    if (avatarVideo) {
                        avatarVideo.src = simulatedVideoUrl;
                        avatarVideo.classList.remove('hidden');
                        avatarVideo.load(); // Load the video
                        // Note: autoplay might be restricted by browser policies, user may need to click play
                        // avatarVideo.play(); 
                    }
                    showMessage('AI avatar video generated!');
                } else {
                    avatarVideoContainer.innerHTML = '<p class="text-red-600">Could not generate avatar video. Simulated API returned no URL.</p>';
                    showMessage('Failed to generate avatar video.', 5000);
                }
            } catch (error) {
                console.error('Error generating avatar video:', error);
                avatarVideoContainer.innerHTML = `<p class="text-red-600">Error generating avatar video: ${error.message}</p>`;
                showMessage('Failed to generate avatar video.', 5000);
            } finally {
                showLoadingSpinner('loading-spinner-avatar', false);
                generateAvatarVideoButton?.removeAttribute('disabled');
                generateAvatarVideoButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                generateAudioFromScriptButton?.removeAttribute('disabled');
                generateAudioFromScriptButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                generateSummaryButton?.removeAttribute('disabled');
                generateSummaryButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                generateScriptButton?.removeAttribute('disabled');
                generateScriptButton?.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        /**
         * Generates a summary using the Gemini API based on the extracted text.
         */
        async function generateSummary() {
            if (!lastExtractedText) {
                showMessage('Please extract text from a PDF first.', 3000);
                return;
            }

            showLoadingSpinner('loading-spinner-summary', true);
            const generateSummaryButton = document.getElementById('generate-summary-button');
            const generateScriptButton = document.getElementById('generate-script-button');
            const generateAudioButton = document.getElementById('generate-audio-button');
            
            generateSummaryButton.disabled = true;
            generateSummaryButton.classList.add('opacity-50', 'cursor-not-allowed');

            generateScriptButton?.setAttribute('disabled', 'true');
            generateScriptButton?.classList.add('opacity-50', 'cursor-not-allowed');
            generateAudioButton?.setAttribute('disabled', 'true');
            generateAudioButton?.classList.add('opacity-50', 'cursor-not-allowed');
            
            const summarizedTextOutput = document.getElementById('summarized-text-output');
            summarizedTextOutput.innerHTML = '<p class="text-gray-600 italic">Generating summary with AI...</p>';

            const prompt = `Summarize the following text: ${lastExtractedText}`;

            const apiUrl = `${BACKEND_BASE}/summary`;
            const payload = { text: lastExtractedText };

            // Exponential backoff retry logic
            const maxRetries = 5;
            let retryCount = 0;
            let response;

            while (retryCount < maxRetries) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        let errorData;
                        try { errorData = await response.json(); } catch { errorData = { detail: 'Unknown error' }; }
                        console.error('API Error:', errorData);
                        if (response.status === 429 || (response.status >= 500 && response.status < 600)) {
                            const delay = Math.pow(2, retryCount) * 1000; 
                            console.warn(`Retrying in ${delay / 1000} seconds... (Attempt ${retryCount + 1})`);
                            await new Promise(res => setTimeout(res, delay));
                            retryCount++;
                            continue; 
                        } else {
                            throw new Error(`API returned status ${response.status}: ${JSON.stringify(errorData)}`);
                        }
                    }
                    // If successful, break the loop
                    break;

                } catch (error) {
                    console.error('Fetch error:', error);
                    summarizedTextOutput.innerHTML = `<p class="text-red-600">Error generating summary: ${error.message}</p>`;
                    showMessage('Failed to generate summary. Please try again.', 5000);
                    showLoadingSpinner('loading-spinner-summary', false);
                    generateSummaryButton?.removeAttribute('disabled');
                    generateSummaryButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                    generateScriptButton?.removeAttribute('disabled');
                    generateScriptButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                    generateAudioButton?.removeAttribute('disabled');
                    generateAudioButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                    return; 
                }
            }

            if (!response || !response.ok) {
                 summarizedTextOutput.innerHTML = '<p class="text-red-600">Max retries reached. Failed to generate summary.</p>';
                 showMessage('Failed to generate summary after multiple attempts.', 5000);
                 showLoadingSpinner('loading-spinner-summary', false);
                 generateSummaryButton?.removeAttribute('disabled');
                 generateSummaryButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                 generateScriptButton?.removeAttribute('disabled');
                 generateScriptButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                 generateAudioButton?.removeAttribute('disabled');
                 generateAudioButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                 return;
            }


            try {
                const result = await response.json();
                const summaryText = result?.summary;
                if (summaryText) {
                    summarizedTextOutput.textContent = summaryText;
                    showMessage('Summary generated successfully!');
                } else {
                    summarizedTextOutput.innerHTML = '<p class="text-red-600">Could not generate a summary. Backend response was empty or malformed.</p>';
                    showMessage('Backend did not return a valid summary.', 5000);
                    console.error('Malformed backend response:', result);
                }
            } catch (error) {
                console.error('Error parsing AI response or accessing content:', error);
                summarizedTextOutput.innerHTML = `<p class="text-red-600">Error processing AI response: ${error.message}</p>`;
                showMessage('Error processing AI response.', 5000);
            } finally {
                showLoadingSpinner('loading-spinner-summary', false);
                generateSummaryButton?.removeAttribute('disabled');
                generateSummaryButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                generateScriptButton?.removeAttribute('disabled');
                generateScriptButton?.classList.remove('opacity-50', 'cursor-not-allowed');
                generateAudioButton?.removeAttribute('disabled');
                generateAudioButton?.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        // --- Event Listeners ---
        document.getElementById('pdf-upload').addEventListener('change', handlePdfUpload);
        document.getElementById('extract-text-button').addEventListener('click', extractText);
        document.getElementById('generate-summary-button').addEventListener('click', generateSummary);
        document.getElementById('generate-script-button').addEventListener('click', generateTeachingScript);
        document.getElementById('generate-audio-button').addEventListener('click', () => generateAndPlayAudio(false));
        document.getElementById('generate-audio-from-script-button').addEventListener('click', () => generateAndPlayAudio(true));
        document.getElementById('generate-avatar-video-button').addEventListener('click', generateAvatarVideo);

        document.addEventListener('DOMContentLoaded', checkBackendHealth);

    </script>
</body>
</html>